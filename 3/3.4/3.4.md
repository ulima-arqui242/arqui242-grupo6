# 3.4. Mapeo entre elementos de Arquitectura

## Mapeo de Comunicación entre Módulos en la Arquitectura

### Contexto:
La aplicación móvil está diseñada como un monolito, lo que implica que todos los módulos se ejecutan en un solo proceso y comparten el mismo espacio de memoria. Esto facilita la implementación y el despliegue, pero requiere una planificación cuidadosa de las interacciones entre los módulos para garantizar un rendimiento óptimo y una buena mantenibilidad. Cada módulo desempeña funciones específicas y necesita comunicarse con otros módulos para operar de manera eficaz.

### Módulos y sus Interacciones:

- **Módulo de Usuarios**:
  - Se comunica con:
    - **Módulo de Chat**: Para recuperar información del usuario y asociar mensajes de chat a los usuarios registrados.
    - **Módulo de Hábitos**: Para obtener datos sobre hábitos del usuario que pueden influir en su interacción en el chat.

- **Módulo de Hábitos**:
  - Se comunica con:
    - **Módulo de Usuarios**: Para obtener información del usuario que está relacionado con sus hábitos.
    - **Módulo de Motivación**: Para enviar notificaciones personalizadas basadas en los hábitos del usuario.

- **Módulo de Seguimiento**:
  - Se comunica con:
    - **Módulo de Usuarios**: Para obtener detalles sobre los usuarios cuyo progreso se está siguiendo.
    - **Módulo de Motivación**: Para enviar mensajes motivacionales basados en el progreso del usuario.

- **Módulo de Motivación**:
  - Se comunica con:
    - **Módulo de Usuarios**: Para enviar notificaciones y pop-ups personalizados a los usuarios.
    - **Módulo de Seguimiento**: Para personalizar los mensajes motivacionales en función del progreso del usuario.

- **Módulo de Chat**:
  - Se comunica con:
    - **Módulo de Usuarios**: Para validar que el usuario esté autenticado y para asociar mensajes a usuarios específicos.

### Alternativas

1. **Comunicación Directa mediante Llamadas de Función**
   - **Descripción**: Cada módulo se comunica directamente con otros mediante llamadas de función o eventos. Esto significa que los módulos invocan métodos de otros módulos en tiempo real, compartiendo el mismo espacio de memoria y proceso.
   - **Ventajas**:
     - Implementación sencilla y rápida, especialmente en una arquitectura monolítica.
     - No requiere intermediarios ni subsistemas adicionales.
     - Facilita la comunicación rápida y eficiente dentro del mismo proceso.
   - **Desventajas**:
     - Puede generar un alto nivel de acoplamiento entre los módulos, dificultando su evolución.
     - Si un módulo cambia su interfaz o funcionalidad, otros módulos podrían verse afectados.
     - No es escalable para arquitecturas futuras más distribuidas.

2. **Mensajería basada en un Bus de Eventos Interno**
   - **Descripción**: Los módulos no se comunican directamente, sino que utilizan un bus de eventos o un sistema de mensajería interna para enviar y recibir información. Este sistema actuaría como un intermediario entre los módulos, capturando y redirigiendo mensajes.
   - **Ventajas**:
     - Reduce el acoplamiento entre módulos, permitiendo que los módulos evolucionen de forma más independiente.
     - Facilita la implementación de patrones de comunicación asincrónicos, mejorando la resiliencia.
     - Mejora la escalabilidad, dado que permite una mayor flexibilidad en el manejo de eventos.
   - **Desventajas**:
     - Introduce una mayor complejidad en la implementación y mantenimiento del sistema de mensajería.
     - Puede aumentar la latencia en la comunicación entre módulos debido al proceso intermediario.
     - Requiere un mayor esfuerzo de monitoreo y trazabilidad de los eventos.

3. **Microservicios Simulados en un Monolito (APIs Internas)**
   - **Descripción**: Cada módulo se abstrae como un servicio independiente, aunque se mantenga dentro del mismo proceso. La comunicación entre módulos se realiza a través de interfaces bien definidas (APIs internas) que simulan la interacción entre microservicios.
   - **Ventajas**:
     - Permite un alto nivel de desacoplamiento, con interfaces claras y definidas entre módulos.
     - Facilita la transición hacia una arquitectura distribuida en el futuro si fuera necesario.
     - Promueve la independencia en la evolución de cada módulo, sin impactar a los demás.
   - **Desventajas**:
     - Aumenta la complejidad al tener que diseñar y mantener APIs internas incluso dentro del monolito.
     - Puede no ser necesario para una aplicación que no esté planificada para escalar hacia una arquitectura distribuida.
     - Genera sobrecarga en la comunicación y gestión de interfaces.

### Criterios de Elección:
- **Cohesión**: Se busca que cada módulo tenga una responsabilidad clara y que la comunicación entre ellos sea fluida.
- **Acoplamiento**: Las interacciones se diseñan para ser lo menos intrusivas posible, facilitando cambios futuros sin afectar a otros módulos.
- **Facilidad de Mantenimiento**: La estructura modular y la claridad en la comunicación entre módulos simplifican la tarea de mantenimiento y actualización de la aplicación.

### Decisión:
Se opta por una comunicación directa entre los módulos mencionados, utilizando llamadas de función o eventos para mantener la interactividad y el flujo de información.

### Sustento:
Este enfoque se alinea con la naturaleza monolítica de la aplicación, donde los módulos constantemente deben trabajar juntos de manera eficiente dentro de un único proceso. Al establecer canales de comunicación claros entre los módulos, se mejora la cohesión y se minimiza el acoplamiento, facilitando así el mantenimiento a largo plazo. La elección de este modelo de comunicación permite que la aplicación sea más reactiva y personalizable, mejorando la experiencia del usuario sin añadir complejidad innecesaria al sistema.

