# 3.4. Mapeo entre elementos de Arquitectura

## Mapeo de Comunicación entre Módulos en la Arquitectura Monolítica

### Contexto:
La aplicación móvil está diseñada como un monolito, lo que implica que todos los módulos se ejecutan en un solo proceso y comparten el mismo espacio de memoria. Esto facilita la implementación y el despliegue, pero requiere una planificación cuidadosa de las interacciones entre los módulos para garantizar un rendimiento óptimo y una buena mantenibilidad. Cada módulo desempeña funciones específicas y necesita comunicarse con otros módulos para operar de manera eficaz.

### Módulos y sus Interacciones:

- **Módulo de Usuarios**:
  - Se comunica con:
    - **Módulo de Chat**: Para recuperar información del usuario y asociar mensajes de chat a los usuarios registrados.
    - **Módulo de Hábitos**: Para obtener datos sobre hábitos del usuario que pueden influir en su interacción en el chat.

- **Módulo de Hábitos**:
  - Se comunica con:
    - **Módulo de Usuarios**: Para obtener información del usuario que está relacionado con sus hábitos.
    - **Módulo de Motivación**: Para enviar notificaciones personalizadas basadas en los hábitos del usuario.

- **Módulo de Seguimiento**:
  - Se comunica con:
    - **Módulo de Usuarios**: Para obtener detalles sobre los usuarios cuyo progreso se está siguiendo.
    - **Módulo de Motivación**: Para enviar mensajes motivacionales basados en el progreso del usuario.

- **Módulo de Motivación**:
  - Se comunica con:
    - **Módulo de Usuarios**: Para enviar notificaciones y pop-ups personalizados a los usuarios.
    - **Módulo de Seguimiento**: Para personalizar los mensajes motivacionales en función del progreso del usuario.

- **Módulo de Chat**:
  - Se comunica con:
    - **Módulo de Usuarios**: Para validar que el usuario esté autenticado y para asociar mensajes a usuarios específicos.

### Alternativas

1. **Comunicación Directa mediante Llamadas de Función**
   - **Descripción**: Cada módulo se comunica directamente con otros mediante llamadas de función o eventos. Esto significa que los módulos invocan métodos de otros módulos en tiempo real, compartiendo el mismo espacio de memoria y proceso.
   - **Ventajas**:
     - Implementación sencilla y rápida, especialmente en una arquitectura monolítica.
     - No requiere intermediarios ni subsistemas adicionales.
     - Facilita la comunicación rápida y eficiente dentro del mismo proceso.
   - **Desventajas**:
     - Puede generar un alto nivel de acoplamiento entre los módulos, dificultando su evolución.
     - Si un módulo cambia su interfaz o funcionalidad, otros módulos podrían verse afectados.
     - No es escalable para arquitecturas futuras más distribuidas.

2. **Mensajería basada en un Bus de Eventos Interno**
   - **Descripción**: Los módulos no se comunican directamente, sino que utilizan un bus de eventos o un sistema de mensajería interna para enviar y recibir información. Este sistema actuaría como un intermediario entre los módulos, capturando y redirigiendo mensajes.
   - **Ventajas**:
     - Reduce el acoplamiento entre módulos, permitiendo que los módulos evolucionen de forma más independiente.
     - Facilita la implementación de patrones de comunicación asincrónicos, mejorando la resiliencia.
     - Mejora la escalabilidad, dado que permite una mayor flexibilidad en el manejo de eventos.
   - **Desventajas**:
     - Introduce una mayor complejidad en la implementación y mantenimiento del sistema de mensajería.
     - Puede aumentar la latencia en la comunicación entre módulos debido al proceso intermediario.
     - Requiere un mayor esfuerzo de monitoreo y trazabilidad de los eventos.

3. **Microservicios Simulados en un Monolito (APIs Internas)**
   - **Descripción**: Cada módulo se abstrae como un servicio independiente, aunque se mantenga dentro del mismo proceso. La comunicación entre módulos se realiza a través de interfaces bien definidas (APIs internas) que simulan la interacción entre microservicios.
   - **Ventajas**:
     - Permite un alto nivel de desacoplamiento, con interfaces claras y definidas entre módulos.
     - Facilita la transición hacia una arquitectura distribuida en el futuro si fuera necesario.
     - Promueve la independencia en la evolución de cada módulo, sin impactar a los demás.
   - **Desventajas**:
     - Aumenta la complejidad al tener que diseñar y mantener APIs internas incluso dentro del monolito.
     - Puede no ser necesario para una aplicación que no esté planificada para escalar hacia una arquitectura distribuida.
     - Genera sobrecarga en la comunicación y gestión de interfaces.

### Criterios de Elección:
- **Cohesión**: Se busca que cada módulo tenga una responsabilidad clara y que la comunicación entre ellos sea fluida.
- **Acoplamiento**: Las interacciones se diseñan para ser lo menos intrusivas posible, facilitando cambios futuros sin afectar a otros módulos.
- **Facilidad de Mantenimiento**: La estructura modular y la claridad en la comunicación entre módulos simplifican la tarea de mantenimiento y actualización de la aplicación.

### Decisión:
Se opta por una comunicación directa entre los módulos mencionados, utilizando llamadas de función o eventos para mantener la interactividad y el flujo de información.

### Sustento:
Este enfoque se alinea con la naturaleza monolítica de la aplicación, donde los módulos deben trabajar juntos de manera eficiente dentro de un único proceso. Al establecer canales de comunicación claros entre los módulos, se mejora la cohesión y se minimiza el acoplamiento, facilitando así el mantenimiento a largo plazo. La elección de este modelo de comunicación permite que la aplicación sea más reactiva y personalizable, mejorando la experiencia del usuario sin añadir complejidad innecesaria al sistema.

# Comparación de Arquitecturas: Monolito vs. Microservicios

### Contexto

La aplicación móvil que estamos desarrollando incluye módulos como Usuarios, Hábitos, Seguimiento, Motivación y Chat. En este punto del diseño arquitectónico, se debe decidir si se implementará una arquitectura monolítica, donde todos los módulos residan en una única aplicación y proceso, o una arquitectura de microservicios, donde cada módulo se despliegue y funcione de forma independiente. Esta decisión afecta no solo cómo los módulos interactúan entre sí, sino también cómo se organizan y asignan los elementos de arquitectura en términos de gestión de despliegue, mantenibilidad, escalabilidad y rendimiento.

### Alternativas

1. **Arquitectura Monolítica**
   - **Descripción**: Todos los módulos de la aplicación (Usuarios, Hábitos, Seguimiento, Motivación y Chat) residen en una única base de código y se ejecutan en un único proceso.
   - **Ventajas**:
     - **Simplicidad de desarrollo y despliegue**: Todo el código está en una base común, lo que facilita el desarrollo y el despliegue en un solo paquete.
     - **Comunicación interna rápida**: Los módulos interactúan directamente, compartiendo memoria y sin necesidad de gestionar servicios externos o redes.
     - **Facilidad de pruebas**: Las pruebas se pueden realizar en un entorno controlado sin la complejidad de coordinar múltiples servicios.
     - **Costes de infraestructura más bajos**: Se requiere menos infraestructura, ya que no es necesario desplegar y orquestar múltiples servicios.
   - **Desventajas**:
     - **Escalabilidad limitada**: La escalabilidad es vertical (escalar aumentando los recursos de un único servidor), lo cual puede ser costoso y tiene un límite.
     - **Falta de flexibilidad en despliegue**: Todos los módulos se despliegan juntos, por lo que un cambio en un módulo requiere un nuevo despliegue completo de la aplicación.
     - **Mantenibilidad a largo plazo**: A medida que la aplicación crece, el código puede volverse más complejo, lo que dificulta la mantenibilidad y puede generar un "monolito inflexible".
     - **Riesgo de fallos compartidos**: Un error en un módulo podría afectar la disponibilidad de toda la aplicación.

2. **Arquitectura de Microservicios**
   - **Descripción**: Cada módulo (Usuarios, Hábitos, Seguimiento, Motivación y Chat) se despliega como un servicio independiente, con comunicación a través de APIs o mensajería asíncrona.
   - **Ventajas**:
     - **Escalabilidad independiente**: Cada módulo puede escalarse horizontalmente de manera independiente, según las necesidades (por ejemplo, el chat puede escalar más que los hábitos).
     - **Flexibilidad de despliegue**: Los módulos se despliegan de forma independiente, permitiendo actualizaciones y mantenimiento sin interrumpir toda la aplicación.
     - **Mejor resiliencia**: Un fallo en un microservicio no necesariamente afecta a otros módulos. Esto mejora la disponibilidad general del sistema.
     - **Mantenimiento modular**: Los módulos son independientes, lo que facilita el mantenimiento y la evolución de cada uno sin afectar al resto.
   - **Desventajas**:
     - **Complejidad**: La implementación y gestión de microservicios introduce complejidad en la orquestación, monitorización, seguridad y manejo de fallos.
     - **Latencia de comunicación**: La comunicación entre módulos se realiza a través de redes, lo que puede aumentar la latencia y la complejidad en el manejo de errores.
     - **Mayor coste de infraestructura**: Microservicios requieren mayor infraestructura (como contenedores, orquestación de servicios, y bases de datos separadas) y herramientas adicionales para monitorización y escalabilidad.
     - **Coordinación de despliegues**: Si bien los servicios son independientes, aún se necesita coordinar los despliegues y versiones de los módulos para evitar inconsistencias.

---

### Criterios de Elección

- **Escalabilidad**: La capacidad de escalar los módulos de la aplicación de manera eficiente, considerando que el módulo de chat tiene mayores requisitos de concurrencia y tráfico.
- **Mantenibilidad**: Facilidad para mantener y evolucionar la aplicación a medida que crezca la base de usuarios y se introduzcan nuevas funcionalidades.
- **Complejidad**: Consideración de la complejidad que el equipo de desarrollo está dispuesto a manejar, tanto en términos de desarrollo como de operación.
- **Rendimiento**: La latencia y rendimiento de la aplicación, especialmente en el módulo de chat que requiere comunicación en tiempo real.
- **Tolerancia a fallos**: Capacidad de aislar fallos para que un error en un módulo no afecte a toda la aplicación.
- **Costos de infraestructura**: Los costos asociados al despliegue y operación de la arquitectura (servidores, contenedores, balanceadores de carga, etc.).
- **Experiencia del equipo**: La experiencia del equipo en trabajar con arquitecturas monolíticas y de microservicios.

---

### Decisión

Se decide utilizar una **arquitectura monolítica** para el desarrollo inicial de la aplicación móvil.

---

### Sustento

1. **Simplicidad en la fase inicial**: Una arquitectura monolítica es más sencilla de implementar y gestionar en las primeras etapas del proyecto. Esto permitirá un desarrollo más ágil, con un menor overhead técnico y una curva de aprendizaje más corta para el equipo.
   
2. **Costos reducidos de infraestructura**: Dado que la aplicación es nueva y aún no tiene una base de usuarios muy grande, la escalabilidad y el despliegue pueden gestionarse de manera eficiente en un monolito. Además, los costos iniciales de infraestructura serán menores.

3. **Menor complejidad operativa**: La arquitectura de microservicios, aunque ofrece ventajas a largo plazo, introduce una complejidad operativa que puede ser innecesaria en este punto. El equipo puede concentrarse en la construcción y entrega rápida de valor sin tener que lidiar con la orquestación y monitorización de múltiples servicios.

4. **Facilidad de transición**: Una vez que la aplicación crezca y requiera mayor escalabilidad, siempre existe la posibilidad de extraer módulos específicos (como el módulo de chat) hacia microservicios. Este enfoque permite escalar de manera incremental según las necesidades reales del sistema.

5. **Menor latencia interna**: Dado que los módulos compartirán el mismo proceso y memoria en un monolito, la comunicación entre ellos será más rápida que a través de una red, lo cual es crítico para el rendimiento del chat y otras funciones dependientes de la interacción en tiempo real.

