# 3.1. Asignación de Responsabilidades
## Asignacion y ADR
## 1. Identificación de Responsabilidades Importantes
La aplicación tiene como objetivo promover el bienestar a través del seguimiento de hábitos, fomentando la comunidad y proporcionando motivación. Las responsabilidades clave se agrupan en:

- **Funciones básicas del sistema**: Registro de usuarios, creación de hábitos, seguimiento de progreso y comunicación entre usuarios.
- **Infraestructura arquitectural**: Gestión de autenticación, almacenamiento de datos, API backend y mecanismos de comunicación en tiempo real.
- **Satisfacción de atributos de calidad**:
  - **Escalabilidad**: Asegurar el manejo eficiente de múltiples usuarios y datos.
  - **Seguridad**: Garantizar autenticación segura y protección de datos.
  - **Usabilidad**: Ofrecer una interfaz intuitiva y personalizada para mantener la motivación del usuario.

## 2. Asignación a Elementos Ejecutables y No Ejecutables

### Módulo de Usuarios

- **Ejecutables**:
  - Backend: API de autenticación y gestión de perfiles.
  - Frontend: Formularios para registro, edición de perfil, y cierre de cuenta.
- **No Ejecutables**:
  - Base de datos: Almacén de usuarios y preferencias.
  - Conector: Token JWT para manejo de sesiones seguras.

### Módulo de Hábitos

- **Ejecutables**:
  - Backend: Lógica para creación, edición y eliminación de hábitos.
  - Frontend: Pantallas de configuración de hábitos.
- **No Ejecutables**:
  - Base de datos: Tabla de hábitos con atributos (frecuencia, metas).
  - Conector: API REST para sincronización con otros módulos.

### Módulo de Seguimiento

- **Ejecutables**:
  - Backend: Generación de estadísticas y manejo del historial.
  - Frontend: Visualización de progreso mediante gráficos.
- **No Ejecutables**:
  - Base de datos: Registro diario de hábitos completados.
  - Conector: API para exportación del historial.

### Módulo de Motivación

- **Ejecutables**:
  - Backend: Servicio de notificaciones automáticas.
  - Frontend: Interfaz para configurar notificaciones personalizadas.
- **No Ejecutables**:
  - Sistema de notificaciones push (Firebase).
  - Repositorio de mensajes motivacionales.

### Módulo de Amigos

- **Ejecutables**:
  - Backend: Gestión de solicitudes de amistad y hábitos compartidos.
  - Frontend: Pantallas de conexión y visualización de progreso de amigos.
- **No Ejecutables**:
  - Base de datos: Relaciones de amistad y hábitos mutuos.
  - Conector: API para sincronización entre usuarios.

### Módulo de Chat

- **Ejecutables**:
  - Backend: Implementación de comunicación en tiempo real mediante WebSockets.
  - Frontend: Interfaz de chat y creación de grupos.
- **No Ejecutables**:
  - Servicio de mensajería (WebSocket Server).
  - Base de datos: Registro de mensajes y grupos de usuarios.

## 3. Estrategias de Asignación

### Descomposición Funcional
Cada módulo se descompone en funcionalidades claras y específicas, garantizando cohesión interna y permitiendo que los desarrolladores trabajen de forma modular e independiente. Por ejemplo:

- El módulo de **Usuarios** se divide en funciones de registro, autenticación, y gestión de perfiles.
- El módulo de **Seguimiento** cubre tanto el registro de hábitos completados como la generación de gráficos de progreso.

### Modelamiento Conceptual
La arquitectura se basa en un modelo conceptual donde los usuarios y los hábitos son las entidades centrales, mientras que las conexiones entre usuarios (amistades) y las notificaciones fomentan la motivación y el compromiso.

### Agrupación Basada en Atributos de Calidad Similares:

- **Usabilidad**: Los módulos de Usuarios y Hábitos priorizan la simplicidad y accesibilidad de las interfaces.
- **Escalabilidad**: Los servicios backend y el manejo de mensajes en tiempo real aseguran que la aplicación soporte un gran volumen de usuarios simultáneamente.
- **Seguridad**: El módulo de Usuarios garantiza autenticación segura mediante cifrado de contraseñas y manejo de sesiones con tokens.


# ADR: Estructura de la Aplicación por Módulos

## Contexto

Estamos desarrollando una aplicación de seguimiento de hábitos para promover el bienestar y el crecimiento personal. La aplicación cuenta con varios módulos funcionales, como Usuarios, Hábitos, Seguimiento, Chat, Amigos y Motivación.

La arquitectura actual está organizada por módulos funcionales, donde cada módulo tiene responsabilidades específicas basadas en las funciones clave de la aplicación. Sin embargo, surgió la necesidad de decidir si debemos seguir dividiendo la aplicación según **funcionalidades** específicas o si sería más beneficioso agrupar los módulos basándonos en **atributos de calidad** compartidos, como **usabilidad**, **seguridad** o **rendimiento**.

La aplicación prioriza aspectos como:
- **Usabilidad**: Para ofrecer una experiencia intuitiva y fluida.
- **Seguridad**: Debido a la necesidad de proteger la información personal y las interacciones de los usuarios.
- **Rendimiento en tiempo real**: Especialmente relevante en las interacciones de chat y notificaciones.

Dada esta diversidad de objetivos, necesitamos tomar una decisión sobre la mejor forma de estructurar los módulos para facilitar el **mantenimiento**, la **escalabilidad** y una experiencia de usuario consistente.

---

## Alternativas

### 1. División por módulos funcionales (Opción actual)
Cada módulo se organiza en torno a una función específica del sistema. Ejemplos:

- **Módulo de Usuarios**: Gestión de registro, inicio de sesión, y perfiles.
- **Módulo de Hábitos**: Creación, edición y eliminación de hábitos.
- **Módulo de Seguimiento**: Registro de hábitos completados, visualización de progreso.
- **Módulo de Chat**: Mensajería en tiempo real entre usuarios.

**Ventajas**:
- **Claridad de responsabilidades**: Cada módulo tiene una función bien definida, lo que facilita que el equipo de desarrollo se concentre en áreas específicas.
- **Facilidad de mantenimiento**: Cambios en una función no afectan a otras.
- **Independencia de equipos**: Equipos de desarrollo pueden trabajar en paralelo sin interferencias.

**Desventajas**:
- **Desafíos de integración**: La integración entre los módulos puede ser más compleja, especialmente si varios módulos dependen del mismo atributo de calidad.
- **Posibles duplicidades**: Podría haber redundancia de lógica, como implementar seguridad en varios módulos.

### 2. División por atributos de calidad (Nueva alternativa)
Agrupar los módulos basándose en los atributos de calidad que priorizan. Por ejemplo, todos los módulos que priorizan **usabilidad** (como Hábitos y Seguimiento) se agruparían en un solo módulo, y los que requieren **alta seguridad** (como Usuarios y Amigos) en otro.

**Ventajas**:
- **Optimización para atributos de calidad específicos**: Los módulos se diseñan de forma que prioricen un atributo (usabilidad, seguridad, etc.), sin interferencias de otras funcionalidades.
- **Simplificación en políticas globales**: Centraliza la lógica relacionada con seguridad o usabilidad, facilitando la implementación de políticas consistentes en el sistema.

**Desventajas**:
- **Complejidad en la asignación de responsabilidades**: La agrupación por atributos de calidad puede diluir las fronteras funcionales, haciendo más difícil asignar responsabilidades claras.
- **Dependencias intermodulares**: Podrían generarse dependencias complejas entre módulos no relacionados funcionalmente, lo que dificultaría la evolución y mantenimiento del sistema.
- **Riesgo de acoplamiento innecesario**: Módulos con responsabilidades dispares podrían acoplarse, lo que contraviene el principio de bajo acoplamiento.

---

## Criterios de Elección

1. **Claridad de responsabilidades**: Necesitamos que cada módulo tenga una función claramente definida, facilitando el desarrollo y mantenimiento.
2. **Escalabilidad**: El sistema debe escalar fácilmente a medida que se añadan nuevas funcionalidades.
3. **Facilidad de mantenimiento**: El enfoque debe permitir que los módulos evolucionen de manera independiente sin generar dependencias innecesarias.
4. **Eficiencia en el desarrollo**: El equipo debe poder trabajar en paralelo sin interferencias ni dependencias complejas entre módulos.

---

## Decisión Final

Decidimos **mantener la división de la aplicación en módulos funcionales** (Usuarios, Hábitos, Seguimiento, Chat, Amigos, Motivación), ya que proporciona una mayor claridad en cuanto a la responsabilidad de cada parte del sistema. Esto facilita el desarrollo, la escalabilidad y la comprensión del flujo de la aplicación.

---

## Sustento

La decisión de mantener una **división funcional** está justificada por varios factores clave:

1. **Experiencia del equipo y eficiencia en el desarrollo**: El equipo ya está familiarizado con una arquitectura modular basada en funciones, lo que reducirá el tiempo de desarrollo y evitará interrupciones innecesarias en un proyecto con tiempos ajustados.
   
2. **Facilidad de mantenimiento y escalabilidad**: La separación funcional permite a cada equipo trabajar de manera independiente, lo que facilita la evolución de los módulos sin generar dependencias cruzadas que puedan complicar el mantenimiento.

3. **Claridad en la asignación de responsabilidades**: Mantener la división funcional asegura que cada módulo tiene una función clara y definida, lo que simplifica la asignación de tareas y facilita la depuración.

4. **Riesgo de acoplamiento en la alternativa por atributos de calidad**: Agrupar por atributos de calidad podría generar dependencias complejas entre módulos no relacionados funcionalmente, dificultando el desarrollo y la evolución.

5. **Flexibilidad futura**: Mantener una estructura modular por funciones facilita la expansión de la aplicación. Cualquier nueva funcionalidad puede integrarse en un módulo existente o crear un módulo nuevo sin necesidad de replantear toda la arquitectura.
