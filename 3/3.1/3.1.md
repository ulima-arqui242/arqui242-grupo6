# 3.1. Asignación de Responsabilidades





### Elección de la estructura de módulos para la aplicación de seguimiento de hábitos

**Contexto**:  
Estamos desarrollando una aplicación de seguimiento de hábitos para promover el bienestar y el crecimiento personal. La aplicación cuenta con varios módulos funcionales, como Usuarios, Hábitos, Seguimiento, Chat, Amigos y Motivación. La arquitectura actual está organizada por módulos funcionales, donde cada módulo tiene responsabilidades específicas basadas en las funciones clave de la aplicación. Sin embargo, surgió la necesidad de decidir si debemos seguir dividiendo la aplicación según **funcionalidades** específicas o si sería más beneficioso agrupar los módulos basándonos en **atributos de calidad** compartidos, como **usabilidad**, **seguridad** o **rendimiento**.

La aplicación prioriza aspectos como:
- **Usabilidad**: Para ofrecer una experiencia intuitiva y fluida.
- **Rendimiento en tiempo real**: Especialmente relevante en las interacciones de chat y notificaciones.
- **Seguridad**: Debido a la necesidad de proteger la información personal y las interacciones de los usuarios.

## Alternativas

### 1. División por módulos funcionales (Opción actual)
Cada módulo se organiza en torno a una función específica del sistema. Ejemplos:

- **Módulo de Usuarios**: Gestión de registro, inicio de sesión, y perfiles.
- **Módulo de Hábitos**: Creación, edición y eliminación de hábitos.
- **Módulo de Seguimiento**: Registro de hábitos completados, visualización de progreso.

**Ventajas**:
- **Claridad de responsabilidades**: Cada módulo tiene una función bien definida, lo que facilita que el equipo de desarrollo se concentre en áreas específicas.
- **Facilidad de mantenimiento**: Cambios en una función no afectan a otras.
- **Independencia de equipos**: Equipos de desarrollo pueden trabajar en paralelo sin interferencias.

**Desventajas**:
- **Desafíos de integración**: La integración entre los módulos puede ser más compleja, especialmente si varios módulos dependen del mismo atributo de calidad.
- **Posibles duplicidades**: Podría haber redundancia de lógica, como implementar seguridad en varios módulos.


### 2. División por atributos de calidad (Nueva alternativa)
Agrupar los módulos basándose en los atributos de calidad que priorizan. Por ejemplo, todos los módulos que priorizan **usabilidad** (como Hábitos y Seguimiento) se agruparían en un solo módulo, y los que requieren **alta seguridad** (como Usuarios y Amigos) en otro.

**Ventajas**:
- **Optimización para atributos de calidad específicos**: Los módulos se diseñan de forma que prioricen un atributo (usabilidad, seguridad, etc.), sin interferencias de otras funcionalidades.
- **Simplificación en políticas globales**: Centraliza la lógica relacionada con seguridad o usabilidad, facilitando la implementación de políticas consistentes en el sistema.

**Desventajas**:
- **Complejidad en la asignación de responsabilidades**: La agrupación por atributos de calidad puede diluir las fronteras funcionales, haciendo más difícil asignar responsabilidades claras.
- **Dependencias intermodulares**: Podrían generarse dependencias complejas entre módulos no relacionados funcionalmente, lo que dificultaría la evolución y mantenimiento del sistema.
- **Riesgo de acoplamiento innecesario**: Módulos con responsabilidades dispares podrían acoplarse, lo que contraviene el principio de bajo acoplamiento.

## Criterios de Elección

1. **Claridad de responsabilidades**: Necesitamos que cada módulo tenga una función claramente definida, facilitando el desarrollo y mantenimiento.
2. **Escalabilidad**: El sistema debe escalar fácilmente a medida que se añadan nuevas funcionalidades.
3. **Facilidad de mantenimiento**: El enfoque debe permitir que los módulos evolucionen de manera independiente sin generar dependencias innecesarias.
4. **Eficiencia en el desarrollo**: El equipo debe poder trabajar en paralelo sin interferencias ni dependencias complejas entre módulos.

## Decisión Final

Decidimos **mantener la división de la aplicación en módulos funcionales**

## Sustento

La decisión de mantener una **división funcional** se justifica por la experiencia del equipo con esta arquitectura, lo que permitirá un desarrollo más ágil y eficiente, minimizando interrupciones en un proyecto con plazos ajustados. La separación funcional facilita el mantenimiento y la escalabilidad, permitiendo que los equipos trabajen de manera independiente y evolutiva, sin crear dependencias cruzadas que puedan complicar el sistema. Además, esta estructura asegura que cada módulo tenga responsabilidades claras, lo que simplifica la asignación de tareas y la depuración. Finalmente, esta elección proporciona la flexibilidad necesaria para expandir la aplicación, permitiendo la integración de nuevas funcionalidades sin reestructurar completamente la arquitectura existente.























## Asignacion de responsabilidades
## 1. Identificación de Responsabilidades Importantes
La aplicación tiene como objetivo promover el bienestar a través del seguimiento de hábitos, fomentando la comunidad y proporcionando motivación. Las responsabilidades clave se agrupan en:

- **Funciones básicas del sistema**: Registro de usuarios, creación de hábitos, seguimiento de progreso y comunicación entre usuarios.
- **Infraestructura arquitectural**: Gestión de autenticación, almacenamiento de datos, API backend y mecanismos de comunicación en tiempo real.
- **Satisfacción de atributos de calidad**:
  - **Escalabilidad**: Asegurar el manejo eficiente de múltiples usuarios y datos.
  - **Seguridad**: Garantizar autenticación segura y protección de datos.
  - **Usabilidad**: Ofrecer una interfaz intuitiva y personalizada para mantener la motivación del usuario.

## 2. Asignación a Elementos Ejecutables y No Ejecutables

#### Módulo de Usuarios

- **Ejecutables**:
  - Backend: API de autenticación y gestión de perfiles.
  - Frontend: Formularios para registro, edición de perfil, y cierre de cuenta.
- **No Ejecutables**:
  - Base de datos: Almacén de usuarios y preferencias.
  - Conector: Token JWT para manejo de sesiones seguras.

#### Módulo de Hábitos

- **Ejecutables**:
  - Backend: Lógica para creación, edición y eliminación de hábitos.
  - Frontend: Pantallas de configuración de hábitos.
- **No Ejecutables**:
  - Base de datos: Tabla de hábitos con atributos (frecuencia, metas).
  - Conector: API REST para sincronización con otros módulos.

#### Módulo de Seguimiento

- **Ejecutables**:
  - Backend: Generación de estadísticas y manejo del historial.
  - Frontend: Visualización de progreso mediante gráficos.
- **No Ejecutables**:
  - Base de datos: Registro diario de hábitos completados.
  - Conector: API para exportación del historial.

#### Módulo de Motivación

- **Ejecutables**:
  - Backend: Servicio de notificaciones automáticas.
  - Frontend: Interfaz para configurar notificaciones personalizadas.
- **No Ejecutables**:
  - Sistema de notificaciones push (Firebase).
  - Repositorio de mensajes motivacionales.

#### Módulo de Amigos

- **Ejecutables**:
  - Backend: Gestión de solicitudes de amistad y hábitos compartidos.
  - Frontend: Pantallas de conexión y visualización de progreso de amigos.
- **No Ejecutables**:
  - Base de datos: Relaciones de amistad y hábitos mutuos.
  - Conector: API para sincronización entre usuarios.

#### Módulo de Chat

- **Ejecutables**:
  - Backend: Implementación de comunicación en tiempo real mediante WebSockets.
  - Frontend: Interfaz de chat y creación de grupos.
- **No Ejecutables**:
  - Servicio de mensajería (WebSocket Server).
  - Base de datos: Registro de mensajes y grupos de usuarios.

### 3. Estrategia: de Asignación

#### Descomposición Funcional
Cada módulo se descompone en funcionalidades claras y específicas, garantizando cohesión interna y permitiendo que los desarrolladores trabajen de forma modular e independiente. Por ejemplo:

- El módulo de **Usuarios** se divide en funciones de registro, autenticación, y gestión de perfiles.
- El módulo de **Seguimiento** cubre tanto el registro de hábitos completados como la generación de gráficos de progreso.

#### Modelamiento Conceptual
La arquitectura se basa en un modelo conceptual donde los usuarios y los hábitos son las entidades centrales, mientras que las conexiones entre usuarios (amistades) y las notificaciones fomentan la motivación y el compromiso.


