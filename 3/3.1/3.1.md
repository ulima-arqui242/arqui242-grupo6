# 3.1. Asignación de Responsabilidades
# ADR: Estructura de la Aplicación por Módulos

## Contexto
Estamos desarrollando una aplicación de seguimiento de hábitos para promover el bienestar y el crecimiento personal. La aplicación cuenta con varios módulos funcionales, como Usuarios, Hábitos, Seguimiento, Chat, Amigos y Motivación.

La arquitectura actual está organizada por módulos funcionales, donde cada módulo tiene responsabilidades específicas basadas en las funciones clave de la aplicación. Sin embargo, nos enfrentamos a la decisión de si debemos seguir dividiendo la aplicación de acuerdo con funcionalidades específicas o si sería más beneficioso agrupar los módulos basándonos en atributos de calidad compartidos, como usabilidad, seguridad o rendimiento.

## La aplicación prioriza aspectos como:

Usabilidad: Para ofrecer una experiencia intuitiva y fluida.
Seguridad: Debido a la necesidad de proteger la información personal y las interacciones de los usuarios.
Rendimiento en tiempo real: Especialmente relevante en las interacciones de chat y notificaciones.
Dada la diversidad de objetivos en cada parte del sistema, surge la necesidad de tomar una decisión sobre la mejor forma de estructurar los módulos para que faciliten el mantenimiento, escalabilidad y una experiencia consistente.

# Decisión
Decidimos mantener la división de la aplicación en módulos funcionales (Usuarios, Hábitos, Seguimiento, Chat, Amigos, Motivación), ya que proporciona una mayor claridad en cuanto a la responsabilidad de cada parte del sistema, lo que facilita el desarrollo y la comprensión del flujo de la aplicación.

## Alternativas Consideradas
### 1. División por módulos funcionales (Opción actual)
Cada módulo se organiza en torno a una función específica del sistema. Ejemplos:

- Módulo de Usuarios: Gestión de registro, inicio de sesión, y perfiles.
- Módulo de Hábitos: Creación, edición y eliminación de hábitos.
- Módulo de Seguimiento: Registro de hábitos completados, visualización de progreso.
- Módulo de Chat: Mensajería en tiempo real entre usuarios.
### Ventajas:

Claridad de responsabilidades: Los módulos están claramente definidos por sus funcionalidades, lo que permite que cada equipo de desarrollo se concentre en una función específica.
Facilidad de mantenimiento: Cambios y mejoras en una función no afectan directamente a otras.
Independencia de equipos: Diferentes equipos pueden trabajar en paralelo en módulos independientes sin interferencias.
### Desventajas:

Desafíos de integración: La integración entre los módulos puede ser más complicada, especialmente si varios módulos dependen del mismo atributo de calidad.
Posibles duplicidades: Podría haber redundancia de código o lógica si varios módulos necesitan implementar soluciones similares para aspectos como seguridad o rendimiento.
### 2. División por atributos de calidad (Nueva alternativa)
Agrupar módulos con base en los atributos de calidad que priorizan. Por ejemplo, todos los módulos que priorizan usabilidad (como Hábitos y Seguimiento) se agruparían en un solo módulo, y los que requieren alta seguridad (como Usuarios y Amigos) en otro.

### Ventajas:

- Optimización para atributos de calidad específicos: Los módulos pueden diseñarse de manera que prioricen un atributo de calidad concreto (por ejemplo, alta usabilidad o alta seguridad) sin que otras funcionalidades interfieran.
- Simplificación en la implementación de políticas globales: Centraliza la lógica relacionada con la seguridad o la usabilidad, facilitando la aplicación de políticas consistentes en todo el sistema.
  
### Desventajas:

- Complejidad en la asignación de responsabilidades: Agrupar por atributos de calidad puede difuminar las fronteras entre las funcionalidades, haciendo que las responsabilidades no sean claras y complicando el desarrollo.
- Dependencias intermodulares: Podría generar fuertes dependencias entre módulos que no comparten una relación funcional directa, lo que dificulta la evolución y el mantenimiento.
- Riesgo de acoplamiento innecesario: Módulos con responsabilidades de diferentes partes del sistema pueden acabar acoplados entre sí, lo que contraviene el principio de bajo acoplamiento.
### Razonamiento
Después de considerar ambas alternativas, optamos por mantener la división funcional debido a varios factores clave:

**Experiencia del equipo y eficiencia en el desarrollo:** El equipo ya tiene experiencia trabajando con una estructura modular basada en funcionalidades, y con un tiempo limitado para completar el proyecto (1 mes y medio), mantener esta estructura asegura que el equipo pueda avanzar sin interrupciones significativas.

**Facilidad de mantenimiento y escalabilidad:** Con la separación funcional, cada equipo puede trabajar de manera independiente en su módulo, realizando cambios sin afectar otros módulos. Esta independencia es crucial cuando se busca iterar rápidamente sobre nuevas funcionalidades o mejoras.

**Claridad en la asignación de responsabilidades:** La separación funcional asegura que cada módulo tenga una responsabilidad clara, lo que facilita la comprensión del sistema y la asignación de tareas de desarrollo. Los desarrolladores sabrán exactamente dónde realizar cambios o correcciones cuando surjan problemas.

**Riesgo de acoplamiento en la alternativa por atributos de calidad:** Si agrupamos módulos por atributos de calidad, podríamos generar dependencias complejas entre partes del sistema que no necesariamente están relacionadas funcionalmente. Por ejemplo, si el módulo de Seguridad engloba tanto el inicio de sesión como la interacción entre usuarios, podrían surgir conflictos al coordinar cambios que afectan a áreas funcionales dispares.

**Flexibilidad futura:** Mantener una estructura modular por funciones facilita la expansión de la aplicación, ya que cualquier nueva funcionalidad podría encajar fácilmente en un módulo nuevo o existente, sin necesidad de replantear la arquitectura en su totalidad.

### Consecuencias
**Mantenimiento claro y enfocado:** Cada módulo funcional tiene una responsabilidad definida, lo que facilita tanto su evolución como su depuración.

**Mayor esfuerzo en coordinación:** Será necesario establecer mecanismos de coordinación eficientes entre módulos para gestionar atributos de calidad comunes (como la seguridad o la usabilidad). Estos mecanismos podrían incluir servicios compartidos o políticas globales, como un servicio centralizado de autenticación para gestionar la seguridad entre los módulos de Usuarios, Amigos y Chat.

**Escalabilidad garantizada:** La separación por funcionalidades permite escalar módulos específicos (como Chat) sin afectar el rendimiento de otros módulos que no requieren tiempo real.
