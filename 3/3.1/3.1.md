# 3.1. Asignación de Responsabilidades
## Asignacion y ADR
## 1. Identificación de Responsabilidades Importantes
La aplicación tiene como objetivo promover el bienestar a través del seguimiento de hábitos, fomentando la comunidad y proporcionando motivación. Las responsabilidades clave se agrupan en:

- **Funciones básicas del sistema**: Registro de usuarios, creación de hábitos, seguimiento de progreso y comunicación entre usuarios.
- **Infraestructura arquitectural**: Gestión de autenticación, almacenamiento de datos, API backend y mecanismos de comunicación en tiempo real.
- **Satisfacción de atributos de calidad**:
  - **Escalabilidad**: Asegurar el manejo eficiente de múltiples usuarios y datos.
  - **Seguridad**: Garantizar autenticación segura y protección de datos.
  - **Usabilidad**: Ofrecer una interfaz intuitiva y personalizada para mantener la motivación del usuario.

## 2. Asignación a Elementos Ejecutables y No Ejecutables

### Módulo de Usuarios

- **Ejecutables**:
  - Backend: API de autenticación y gestión de perfiles.
  - Frontend: Formularios para registro, edición de perfil, y cierre de cuenta.
- **No Ejecutables**:
  - Base de datos: Almacén de usuarios y preferencias.
  - Conector: Token JWT para manejo de sesiones seguras.

### Módulo de Hábitos

- **Ejecutables**:
  - Backend: Lógica para creación, edición y eliminación de hábitos.
  - Frontend: Pantallas de configuración de hábitos.
- **No Ejecutables**:
  - Base de datos: Tabla de hábitos con atributos (frecuencia, metas).
  - Conector: API REST para sincronización con otros módulos.

### Módulo de Seguimiento

- **Ejecutables**:
  - Backend: Generación de estadísticas y manejo del historial.
  - Frontend: Visualización de progreso mediante gráficos.
- **No Ejecutables**:
  - Base de datos: Registro diario de hábitos completados.
  - Conector: API para exportación del historial.

### Módulo de Motivación

- **Ejecutables**:
  - Backend: Servicio de notificaciones automáticas.
  - Frontend: Interfaz para configurar notificaciones personalizadas.
- **No Ejecutables**:
  - Sistema de notificaciones push (Firebase).
  - Repositorio de mensajes motivacionales.

### Módulo de Amigos

- **Ejecutables**:
  - Backend: Gestión de solicitudes de amistad y hábitos compartidos.
  - Frontend: Pantallas de conexión y visualización de progreso de amigos.
- **No Ejecutables**:
  - Base de datos: Relaciones de amistad y hábitos mutuos.
  - Conector: API para sincronización entre usuarios.

### Módulo de Chat

- **Ejecutables**:
  - Backend: Implementación de comunicación en tiempo real mediante WebSockets.
  - Frontend: Interfaz de chat y creación de grupos.
- **No Ejecutables**:
  - Servicio de mensajería (WebSocket Server).
  - Base de datos: Registro de mensajes y grupos de usuarios.

## 3. Estrategias de Asignación

### Descomposición Funcional
Cada módulo se descompone en funcionalidades claras y específicas, garantizando cohesión interna y permitiendo que los desarrolladores trabajen de forma modular e independiente. Por ejemplo:

- El módulo de **Usuarios** se divide en funciones de registro, autenticación, y gestión de perfiles.
- El módulo de **Seguimiento** cubre tanto el registro de hábitos completados como la generación de gráficos de progreso.

### Modelamiento Conceptual
La arquitectura se basa en un modelo conceptual donde los usuarios y los hábitos son las entidades centrales, mientras que las conexiones entre usuarios (amistades) y las notificaciones fomentan la motivación y el compromiso.

### Agrupación Basada en Atributos de Calidad Similares:

- **Usabilidad**: Los módulos de Usuarios y Hábitos priorizan la simplicidad y accesibilidad de las interfaces.
- **Escalabilidad**: Los servicios backend y el manejo de mensajes en tiempo real aseguran que la aplicación soporte un gran volumen de usuarios simultáneamente.
- **Seguridad**: El módulo de Usuarios garantiza autenticación segura mediante cifrado de contraseñas y manejo de sesiones con tokens.


# ADR: Estructura de la Aplicación por Módulos

### Contexto
Estamos desarrollando una aplicación de seguimiento de hábitos para promover el bienestar y el crecimiento personal. La aplicación cuenta con varios módulos funcionales, como Usuarios, Hábitos, Seguimiento, Chat, Amigos y Motivación.

La arquitectura actual está organizada por módulos funcionales, donde cada módulo tiene responsabilidades específicas basadas en las funciones clave de la aplicación. Sin embargo, nos enfrentamos a la decisión de si debemos seguir dividiendo la aplicación de acuerdo con funcionalidades específicas o si sería más beneficioso agrupar los módulos basándonos en atributos de calidad compartidos, como usabilidad, seguridad o rendimiento.

### La aplicación prioriza aspectos como:

Usabilidad: Para ofrecer una experiencia intuitiva y fluida.
Seguridad: Debido a la necesidad de proteger la información personal y las interacciones de los usuarios.
Rendimiento en tiempo real: Especialmente relevante en las interacciones de chat y notificaciones.
Dada la diversidad de objetivos en cada parte del sistema, surge la necesidad de tomar una decisión sobre la mejor forma de estructurar los módulos para que faciliten el mantenimiento, escalabilidad y una experiencia consistente.

### Decisión
Decidimos mantener la división de la aplicación en módulos funcionales (Usuarios, Hábitos, Seguimiento, Chat, Amigos, Motivación), ya que proporciona una mayor claridad en cuanto a la responsabilidad de cada parte del sistema, lo que facilita el desarrollo y la comprensión del flujo de la aplicación.

### Alternativas Consideradas
###  1. División por módulos funcionales (Opción actual)
Cada módulo se organiza en torno a una función específica del sistema. Ejemplos:

- Módulo de Usuarios: Gestión de registro, inicio de sesión, y perfiles.
- Módulo de Hábitos: Creación, edición y eliminación de hábitos.
- Módulo de Seguimiento: Registro de hábitos completados, visualización de progreso.
- Módulo de Chat: Mensajería en tiempo real entre usuarios.
### Ventajas:

Claridad de responsabilidades: Los módulos están claramente definidos por sus funcionalidades, lo que permite que cada equipo de desarrollo se concentre en una función específica.
Facilidad de mantenimiento: Cambios y mejoras en una función no afectan directamente a otras.
Independencia de equipos: Diferentes equipos pueden trabajar en paralelo en módulos independientes sin interferencias.
### Desventajas:

Desafíos de integración: La integración entre los módulos puede ser más complicada, especialmente si varios módulos dependen del mismo atributo de calidad.
Posibles duplicidades: Podría haber redundancia de código o lógica si varios módulos necesitan implementar soluciones similares para aspectos como seguridad o rendimiento.
### 2. División por atributos de calidad (Nueva alternativa)
Agrupar módulos con base en los atributos de calidad que priorizan. Por ejemplo, todos los módulos que priorizan usabilidad (como Hábitos y Seguimiento) se agruparían en un solo módulo, y los que requieren alta seguridad (como Usuarios y Amigos) en otro.

### Ventajas:

- Optimización para atributos de calidad específicos: Los módulos pueden diseñarse de manera que prioricen un atributo de calidad concreto (por ejemplo, alta usabilidad o alta seguridad) sin que otras funcionalidades interfieran.
- Simplificación en la implementación de políticas globales: Centraliza la lógica relacionada con la seguridad o la usabilidad, facilitando la aplicación de políticas consistentes en todo el sistema.
  
### Desventajas:

- Complejidad en la asignación de responsabilidades: Agrupar por atributos de calidad puede difuminar las fronteras entre las funcionalidades, haciendo que las responsabilidades no sean claras y complicando el desarrollo.
- Dependencias intermodulares: Podría generar fuertes dependencias entre módulos que no comparten una relación funcional directa, lo que dificulta la evolución y el mantenimiento.
- Riesgo de acoplamiento innecesario: Módulos con responsabilidades de diferentes partes del sistema pueden acabar acoplados entre sí, lo que contraviene el principio de bajo acoplamiento.
### Razonamiento
Después de considerar ambas alternativas, optamos por mantener la división funcional debido a varios factores clave:

**Experiencia del equipo y eficiencia en el desarrollo:** El equipo ya tiene experiencia trabajando con una estructura modular basada en funcionalidades, y con un tiempo limitado para completar el proyecto (1 mes y medio), mantener esta estructura asegura que el equipo pueda avanzar sin interrupciones significativas.

**Facilidad de mantenimiento y escalabilidad:** Con la separación funcional, cada equipo puede trabajar de manera independiente en su módulo, realizando cambios sin afectar otros módulos. Esta independencia es crucial cuando se busca iterar rápidamente sobre nuevas funcionalidades o mejoras.

**Claridad en la asignación de responsabilidades:** La separación funcional asegura que cada módulo tenga una responsabilidad clara, lo que facilita la comprensión del sistema y la asignación de tareas de desarrollo. Los desarrolladores sabrán exactamente dónde realizar cambios o correcciones cuando surjan problemas.

**Riesgo de acoplamiento en la alternativa por atributos de calidad:** Si agrupamos módulos por atributos de calidad, podríamos generar dependencias complejas entre partes del sistema que no necesariamente están relacionadas funcionalmente. Por ejemplo, si el módulo de Seguridad engloba tanto el inicio de sesión como la interacción entre usuarios, podrían surgir conflictos al coordinar cambios que afectan a áreas funcionales dispares.

**Flexibilidad futura:** Mantener una estructura modular por funciones facilita la expansión de la aplicación, ya que cualquier nueva funcionalidad podría encajar fácilmente en un módulo nuevo o existente, sin necesidad de replantear la arquitectura en su totalidad.

### Consecuencias
**Mantenimiento claro y enfocado:** Cada módulo funcional tiene una responsabilidad definida, lo que facilita tanto su evolución como su depuración.

**Mayor esfuerzo en coordinación:** Será necesario establecer mecanismos de coordinación eficientes entre módulos para gestionar atributos de calidad comunes (como la seguridad o la usabilidad). Estos mecanismos podrían incluir servicios compartidos o políticas globales, como un servicio centralizado de autenticación para gestionar la seguridad entre los módulos de Usuarios, Amigos y Chat.

**Escalabilidad garantizada:** La separación por funcionalidades permite escalar módulos específicos (como Chat) sin afectar el rendimiento de otros módulos que no requieren tiempo real.
